<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>サイコロふるやつ｜Dice Roller 3D</title>
  <meta name="description" content="好きな数のサイコロを選んで、3Dでコロコロ転がして結果を共有できるWebアプリ" />
  <style>
    :root {
      --bg: #0f172a;        /* slate-900 */
      --card: #111827;      /* gray-900 */
      --muted: #94a3b8;     /* slate-400 */
      --text: #e5e7eb;      /* gray-200 */
      --accent: #22d3ee;    /* cyan-400 */
      --accent-2: #a78bfa;  /* violet-400 */
      --shadow: 0 10px 25px rgba(0,0,0,.35);
      --radius: 1.25rem;
      --die-size: 84px;
    }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans JP", "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 600px at 20% 0%, #0b1228, var(--bg)),
                  radial-gradient(1200px 800px at 120% 120%, #111435, var(--bg));
      color: var(--text);
      display: grid; place-items: center;
      padding: 24px;
    }
    .app { width: min(960px, 100%); }
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border: 1px solid rgba(148,163,184,.18);
      backdrop-filter: blur(6px);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: clamp(16px, 3vw, 28px);
    }
    header h1 { margin: 0 0 6px; font-size: clamp(20px, 3.4vw, 32px); letter-spacing: .02em; }
    header p { margin: 0; color: var(--muted); font-size: 14px; }

    .controls { display: grid; gap: 12px; grid-template-columns: 1fr; margin-top: 18px; }
    @media (min-width: 560px) {
      .controls { grid-template-columns: 1fr auto auto; align-items: end; }
    }

    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    select, button {
      appearance: none; -webkit-appearance: none;
      border-radius: .9rem; border: 1px solid rgba(148,163,184,.25);
      background: #0b1224; color: var(--text);
      padding: 12px 14px; font-size: 16px;
      transition: transform .05s ease, box-shadow .2s ease, border-color .2s ease;
    }
    select:focus, button:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(34,211,238,.25); }
    button { cursor: pointer; font-weight: 600; }
    .roll { background: linear-gradient(90deg, var(--accent), var(--accent-2)); border: none; color: #0b0f1c; }
    .roll:active { transform: translateY(1px); }
    .reset { background: transparent; }

    .dice-grid {
      margin-top: 18px;
      display: grid; gap: 14px;
      grid-template-columns: repeat(auto-fill, minmax(var(--die-size), 1fr));
    }

    /* 3D dice */
    .die {
      position: relative;
      width: var(--die-size); height: var(--die-size);
      margin: 0 auto; /* center in grid cell */
      perspective: 800px;
    }
    .cube {
      position: absolute; inset: 0;
      transform-style: preserve-3d;
      transition: transform 1s cubic-bezier(.2,.7,.1,1);
    }
    .face {
      position: absolute; inset: 0;
      background: #f8fafc; /* slate-50 */
      border-radius: 14px;
      border: 2px solid #0b1020;
      box-shadow: inset 0 3px 8px rgba(0,0,0,.08);
      display: grid; place-items: center;
    }
    .pip { fill: #0b1020; }

    /* place faces around cube (size/2 = 42px) */
    .front  { transform: translateZ(calc(var(--die-size)/2)); }
    .back   { transform: rotateY(180deg) translateZ(calc(var(--die-size)/2)); }
    .right  { transform: rotateY(90deg) translateZ(calc(var(--die-size)/2)); }
    .left   { transform: rotateY(-90deg) translateZ(calc(var(--die-size)/2)); }
    .top    { transform: rotateX(90deg) translateZ(calc(var(--die-size)/2)); }
    .bottom { transform: rotateX(-90deg) translateZ(calc(var(--die-size)/2)); }

    .summary {
      margin-top: 14px; display: flex; gap: 12px; flex-wrap: wrap; align-items: center; justify-content: space-between;
      color: var(--muted); font-size: 14px;
    }
    .summary strong { color: var(--text); font-size: 16px; }

    .hint { margin-top: 6px; font-size: 12px; color: var(--muted); }
    .footer { margin-top: 16px; font-size: 12px; color: var(--muted); text-align: right; }
    .footer a { color: var(--accent); text-decoration: none; }
  </style>
</head>
<body>
  <main class="app card" role="main">
    <header>
      <h1>サイコロをふる（3D）🧊</h1>
      <p>個数を選んで「ふる」を押すだけ。3Dでコロコロ転がります <span aria-hidden="true">🎲</span></p>
    </header>

    <section class="controls" aria-label="コントロール">
      <div>
        <label for="diceCount">サイコロの個数</label>
        <select id="diceCount" aria-label="サイコロの個数"></select>
        <div class="hint">↑ 最大12個まで。キーボード <kbd>R</kbd> でもふれます。</div>
      </div>
      <button class="roll" id="rollBtn" aria-label="サイコロをふる">ふる</button>
      <button class="reset" id="resetBtn" aria-label="リセット">リセット</button>
    </section>

    <section class="dice-grid" id="diceGrid" aria-live="polite" aria-label="出目の一覧"></section>

    <div class="summary" id="summary" aria-live="polite">
      <div>合計: <strong id="total">-</strong></div>
      <div>出目: <span id="results">-</span></div>
    </div>

    <section class="info">
      <h2>このサイコロアプリについて</h2>
      <p>このオンラインサイコロは、ブラウザだけで簡単にダイスを振れる無料ツールです。ゲームやボードゲーム、TRPG、授業やイベントでの抽選などに使えます。最大12個のサイコロを同時に振り、3Dでコロコロ転がる動きを楽しめます。結果の共有リンクもワンクリックで発行可能なので、遠隔地の友達やオンライン会議でも活用できます。</p>
    </section>

    <div class="footer">Made with <span aria-hidden="true">♥</span> — <a href="#" id="copyLink">結果URLをコピー</a></div>
  </main>

  <script>
    // --- 3D Dice Roller ---
    const elCount = document.getElementById('diceCount');
    const elGrid = document.getElementById('diceGrid');
    const elTotal = document.getElementById('total');
    const elResults = document.getElementById('results');
    const elRoll = document.getElementById('rollBtn');
    const elReset = document.getElementById('resetBtn');
    const elCopy = document.getElementById('copyLink');

    // populate select 1..12
    for (let i = 1; i <= 12; i++) {
      const opt = document.createElement('option');
      opt.value = String(i);
      opt.textContent = `${i} 個`;
      elCount.appendChild(opt);
    }

    let count = 3; // default dice count
    let values = [];

    // SVG for pips (7 pip positions in 3x3 grid)
    function faceSVG(n) {
      const size = 76; // inner pad a bit inside die
      const r = 5.8;
      const coords = {
        1: [[0,0]],
        2: [[-1,-1],[1,1]],
        3: [[-1,-1],[0,0],[1,1]],
        4: [[-1,-1],[1,-1],[-1,1],[1,1]],
        5: [[-1,-1],[1,-1],[0,0],[-1,1],[1,1]],
        6: [[-1,-1],[1,-1],[-1,0],[1,0],[-1,1],[1,1]],
      }[n];
      const half = size/2;
      const step = size/3.2;
      const circles = coords.map(([gx,gy]) => {
        const cx = half + gx*step;
        const cy = half + gy*step;
        return `<circle class="pip" cx="${cx}" cy="${cy}" r="${r}" />`;
      }).join('');
      return `<svg width="100%" height="100%" viewBox="0 0 ${size} ${size}" aria-hidden="true" focusable="false">${circles}</svg>`;
    }

    function makeDieElement(index) {
      const die = document.createElement('div');
      die.className = 'die';
      const cube = document.createElement('div');
      cube.className = 'cube';

      const faces = [
        ['top',    1], // top shows face 1
        ['bottom', 6],
        ['front',  2],
        ['back',   5],
        ['right',  3],
        ['left',   4],
      ];
      faces.forEach(([cls, num]) => {
        const f = document.createElement('div');
        f.className = `face ${cls}`;
        f.innerHTML = faceSVG(num);
        cube.appendChild(f);
      });
      die.appendChild(cube);
      return die;
    }

    function setCount(n) {
      count = Math.max(1, Math.min(12, n|0));
      elCount.value = String(count);
      renderDice();
      updateSummary();
    }

    function renderDice() {
      elGrid.innerHTML = '';
      for (let i = 0; i < count; i++) {
        elGrid.appendChild(makeDieElement(i));
      }
    }

    function rollOnce() { return Math.floor(Math.random() * 6) + 1; }

    // Rotations that bring the given face to FRONT (toward the viewer)
    // We only use X/Y full rotations so the visible face always equals the value.
    const orientation = {
      1: {x:  -90, y:   0},  // top -> front
      2: {x:    0, y:   0},  // front stays front
      3: {x:    0, y: -90},  // right -> front
      4: {x:    0, y:  90},  // left  -> front
      5: {x:    0, y: 180},  // back  -> front
      6: {x:   90, y:   0},  // bottom-> front
    };

    function rollDice() {
      const dice = Array.from(elGrid.querySelectorAll('.cube'));
      values = [];
      dice.forEach((cube, i) => {
        const v = rollOnce();
        values.push(v);
        const base = orientation[v];
        // add extra full spins only on X/Y so the visible face remains correct
        const spinX = 360 * (1 + Math.floor(Math.random()*3));
        const spinY = 360 * (1 + Math.floor(Math.random()*3));
        const rx = base.x + spinX;
        const ry = base.y + spinY;
        // Stagger slightly
        const delay = i * 60;
        cube.style.transition = `transform 900ms cubic-bezier(.2,.7,.1,1) ${delay}ms`;
        cube.style.transform = `rotateX(${rx}deg) rotateY(${ry}deg)`;
        // ARIA label on parent die
        cube.parentElement.setAttribute('aria-label', `${i+1}個目: ${v}`);
      });
      setTimeout(() => { updateSummary(); updateURL(); }, 950 + (dice.length-1)*60);
    }

    function updateSummary() {
      if (!values.length) {
        elTotal.textContent = '-';
        elResults.textContent = '-';
        return;
      }
      const sum = values.reduce((a,b)=>a+b,0);
      elTotal.textContent = String(sum);
      elResults.textContent = values.join(', ');
    }

    function resetAll() {
      values = [];
      // reset cubes to neutral pose
      elGrid.querySelectorAll('.cube').forEach(c => { c.style.transform = 'rotateX(0deg) rotateY(0deg)'; c.style.transition = 'transform 300ms ease'; });
      updateSummary();
      updateURL(true);
    }

    // Share results via URL (?n=3&v=1-6-2)
    function updateURL(clear=false) {
      const params = new URLSearchParams(window.location.search);
      params.set('n', String(count));
      if (values.length && !clear) {
        params.set('v', values.join('-'));
      } else {
        params.delete('v');
      }
      const url = `${location.pathname}?${params.toString()}`;
      history.replaceState(null, '', url);
    }

    function loadFromURL() {
      const params = new URLSearchParams(window.location.search);
      const n = parseInt(params.get('n') || '3', 10);
      const v = (params.get('v') || '').split('-').map(x=>parseInt(x,10)).filter(Boolean);
      setCount(isNaN(n) ? 3 : n);
      if (v.length) {
        values = v.slice(0, count);
        // pose cubes to match values
        const dice = Array.from(elGrid.querySelectorAll('.cube'));
        dice.forEach((cube, i) => {
          const val = values[i] || 1;
          const base = orientation[val];
          cube.style.transform = `rotateX(${base.x}deg) rotateY(${base.y}deg)`;
        });
        updateSummary();
      }
    }

    // Events
    elCount.addEventListener('change', (e)=> { setCount(parseInt(e.target.value,10)); updateURL(); });
    elRoll.addEventListener('click', rollDice);
    elReset.addEventListener('click', resetAll);
    document.addEventListener('keydown', (e)=>{ if (e.key.toLowerCase()==='r') rollDice(); });
    elCopy.addEventListener('click', (e)=>{
      e.preventDefault();
      navigator.clipboard.writeText(location.href).then(()=>{
        elCopy.textContent = 'コピーしました！';
        setTimeout(()=> elCopy.textContent = '結果URLをコピー', 1400);
      });
    });

    // init
    setCount(3);
    renderDice();
    loadFromURL();
  </script>
</body>
</html>
